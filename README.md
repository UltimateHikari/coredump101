## Coredump 101

До сих пор при виде Segmentation fault (core dumped) идешь отлаживаться россыпью логов и флашей?
Можно куда быстрее локализовать проблему.

### Что это такое

Core dump // дамп памяти - файл, содержащий адресное пространство процесса при падении.
Из них при должной сноровке вытаскиваются состояния всех потоков, переменных и просто содержимое по адресу.
Логичное следствие - дамп может быть очень большим, надо принимать во внимание, если на машине мало места.

### Что нужно для настройки

* если не пишут (core dumped), проверь 
```
ulimit -c
```
если там `0` - поправь, например
```
ulimit -c unlimited
```
* чтобы не видеть ?? в `gdb`, надо собрать с отладочными символами, например
```
gcc <source> -g
```
* посмотреть на 
```
sysctl kernel.core_pattern
```
чтобы понять, кто и куда сейчас собирает дампы, и при необходимости поправить.
по умолчанию там `kernel.core_pattern = core`

### Простой способ

* echo "core-%e.%p" > /proc/sys/kernel/core_pattern
* корка появится в той же директории, откуда запустили бинарник
```
$ ./segv.out; ls
Segmentation fault (core dumped)
core-segv.out.1726060  corethread.c  segv.out
```
* грузим ее в gdb (см. пример применения):
```
$ gdb segv.out core-segv.out.1726060
```

### Способ для ленивых

Чтобы не собирать потом гигабайтные дампы после нескольких запусков, можно использовать автоматически сбор корок, например, `apport` или `systemd-coredump`.
Здесь пример для второго, ибо `systemd` проникла в большинство линуксовых дистрибутивов.

* ставим, если его еще нет:
```
Ubuntu/Debian:
$ sudo apt update && apt install -y systemd-coredump
```
* проверяем core_pattern, если с ним игрались. там должно быть что-то вроде
```
kernel.core_pattern=|/lib/systemd/systemd-coredump %P %u %g %s %t 9223372036854775808 %h
```
* если нет, перезагружаем
```
systemctl start systemd-coredump
```
* после этого список найденных и перемещенных корок доступен как
```
coredumpctl list
```
* засунуть в gdb последнюю можно через
```
coredumpctl debug
```
* а непоследнюю - взяв из list ее pid
```
coredumpctl gdb <pid>
```
* сами файлы, скорее всего, лежат где-то в
```
$ ls /var/lib/systemd/coredump
core.gdb.1000.e5bbd9a3cab7442aa2bb9934c44ced3c.12539.1728976722000000.zst
```
* в принципе, никто не мешает вытащить их, разархивировать и самостоятельно отдать gdb. Например, если coredumpctl поломался и не видит бинарник, и поэтому в бэктрейсе сплошные ??()

### Пример использования 
```
$ make
$ ./segv.out; ls
Segmentation fault (core dumped)
core-segv.out.1726060  corethread.c  segv.out
$ gdb ./segv.out ./core-segv.out.1726060
...
Reading symbols from ./segv.out...
[New LWP 1726061]
[New LWP 1726060]

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) n
Debuginfod has been disabled.
To make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./segv.out'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00005f87284161e8 in seg_func () at corethread.c:9
9               printf("%d", *a);
[Current thread is 1 (Thread 0x76817e7ff6c0 (LWP 1726061))]
(gdb) thread apply all bt

Thread 2 (Thread 0x76817eb6e740 (LWP 1726060)):
#0  0x000076817e8940f6 in __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, expected=1726061, futex_word=0x76817e7ff990) at ./nptl/futex-internal.c:57
#1  __futex_abstimed_wait_common (cancel=true, private=128, abstime=0x0, clockid=0, expected=1726061, futex_word=0x76817e7ff990) at ./nptl/futex-internal.c:87
#2  __GI___futex_abstimed_wait_cancelable64 (futex_word=futex_word@entry=0x76817e7ff990, expected=1726061, clockid=clockid@entry=0, abstime=abstime@entry=0x0, private=private@entry=128) at ./nptl/futex-internal.c:139
#3  0x000076817e899693 in __pthread_clockjoin_ex (threadid=130298545174208, thread_return=0x7ffed1124970, clockid=0, abstime=0x0, block=<optimized out>) at ./nptl/pthread_join_common.c:102
#4  0x00005f8728416291 in main () at corethread.c:26

Thread 1 (Thread 0x76817e7ff6c0 (LWP 1726061)):
#0  0x00005f87284161e8 in seg_func () at corethread.c:9
#1  0x00005f872841622c in thread_routine () at corethread.c:15
#2  0x000076817e897b5a in start_thread (arg=<optimized out>) at ./nptl/pthread_create.c:444
#3  0x000076817e9285fc in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:78
(gdb) print a
$1 = (int *) 0x0
(gdb) quit
```

